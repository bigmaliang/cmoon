应用需求
=======
    Web 即时通信, 浏览器即时获取服务器端, 或其他用户浏览器端数据(事件, 聊天信息等)



实现方式
=======
    当前 web 即时通信的实现方式有以下几种:
    
    1, 轮询拉取     ajax 定时或者变时发起获取数据请求
    2, 长连接通信   ajax/iframe 保持客户端与服务器端的长连接 socket 请求, 实现数据的即时获取
    3, HTML 5 之 WebSocket
    4, Flash, activex 插件之类

    由于方法1不能真正算是即时数据通信, 3 的标准还没制定出来, 各个浏览器还不能完全支持,
    4 需要安装插件, 跨浏览器兼容性也有问题, 这里主要说明第 2 种方式.

    cometd (http://en.wikipedia.org/wiki/Comet_%28programming%29)
    (http://cometd.org/) 整理了当前比较成熟的长连接通信实现方案,
    大概有以下几种(关于各种方式的详细说明请参考上面连接):
        A, Streaming
            A.1 Hidden Iframe
            A.2 XHR Streaming
            
        B, Ajax with long polling
            B.1 XHR Long polling
            B.2 JSONP

    当前 cometd 有许多基于 Java, Python, Perl, C... 的实现,
    APE(http://www.ape-project.org/) 便是其中一种.


APE 工作模型
===========
    无论是streaming, 还是long polling 方式, 都需要在客户端和服务器之间保持长连接
    请求以获取即时数据, ape 开发了一个特殊的 http 服务器, 一套 js 库,
    实现了一套轻便, 可靠的长连接通信底层.

    由于需要实现客户端与客户端的即时通信, 所以一个应用(应用通信需求, 比如某某活动)的
    客户端需要连向同一台服务器, 或者多台服务器之间需要共享连接信息, 才能实现客户端之间的
    即时通信.



关于 ape 扩展
============
    试想多台服务器同时服务一个业务的情况, 数据要从服务器传到所有有获取需求的客户端,
    如果客户端 *随机离散* 连接在各个 ape 服务器上, 实现数据传送需要进行如下操作
    1, 查询出 数据要传送给哪些客户端
    2, 查询出 这些客户端当前的在线状态和具体位置
    3, 向具体的服务器传送数据
    4, 服务器向连在他上面的客户端推送数据
    有两个问题需要解决:
    A, 供 ape 服务器查询客户端关系和在线状态的接口
    B, ape 服务器之间的数据传送

    解决问题A有两种方法: 一台服务器统一管理, 或者多个分布式服务器提供一个统一的接口
    (类似memcached)
    前者对于缓解压力没有实际意义.  问题B也比较容易实现.  所以最终, ape 服务器分布式的瓶颈
    在于客户端关系和在线状态, 位置的查询接口.

    在实现了分布式扩展的同时, 也为每次数据的传递增加了 1 + N 次网络通信(1次数据查询,
    和N次ape服务器之间的数据传递, N为需要获取该信息的在线用户数)
